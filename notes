# Section 01_01: Inversion of Control Pattern
Spring is an open-source framework for Java applications that provides dependency injection of Spring Beans via 
Spring application context, which follows the inversion-of-control desing pattern.

Dependency Injection (DI) Principle
- Separates the usage of objects from the lifecycle of their dependent objects
- Creation of the dependencies of a class is managed outside the class
- Makes application more flexible and maintainable and easier to test 

Inversion-of-Control Framework
- Maintains lifecycle of an object and its dependencies
- Requires dependency injection
- Class "relinquishes control" to the framework

Spring Context
- Also known as spring container
- The core Spring inversion-of-control framework

Spring Bean
- Java object managed by the Spring application context
- Singleton scope by default
- Other scopes: prototype, request, session

DI Configuration
- Originally via XML files: difficult to manage
- Java classes:
  - Annotated method: @Bean method within an @Configuration class
  - Annotated class such as @Component, @Service, @Repository

# Section 01_02: Spring ApplicationContext and Spring Beans
- A SprinBeans class was created, defining the different Beans (repository, tourManagement and TravelAgent).
  This is the configuration for the dependency injection.

- A context was then loaded with the Spring Beans class in the main application: 
  "ApplicationContext context = new AnnotationConfigApplicationContext(SpringBeans.class);"

- Instantiation of TravelAgentService object was performed from the context Bean:
  "TravelAgentService agent = context.getBean(TravelAgentService.class);"

# Section 01_03: Spring autowiring annotations
- Another way to configure dependency injection is with autowiring

- For using the autowire functionality for DI, we need to annotate the different class layers:
- - Repository with @Repository
- - Services with @Service

- With these annotations we do not need the spring beans class that instantiates the class objects with explicit dependencies

- Since the spring beans class is removed, we need to adapt the instantiation of the context in the application. 
  We will scan for the dependency packages:
"ApplicationContext context = new AnnotationConfigApplicationContext(SpringBeans.class);"
                                           |
                                           V
"ApplicationContext context = new AnnotationConfigApplicationContext(Application.class.getPackageName());"

# Section 02_01: Introduction to Spring Initialzr
- Spring Initializr:
- - Is a tool for creating spring boot projects
- - Creates a packages structure
- - Creates the pom.xml/build.gradle files
- - Creates Java source classes

- Our first spring boot microservice will be a Web application for relational DB, requiring the dependencies:
- - Spring Web, which includes Tomcat and Spring MVC
- - Rest repositories to access Spring repositories via REST
- - Java persistence API (JPA)
- - Lombok: generates getters/setters/logger bytecode
- - H2 in memory database driver

# Section 02_03: Build, deploy, and launch the microservice
All steps via cli inside the project folder:
- Build: mvn clean install. A jar file for the application is built in the /target folder after the command terminates
- Run application: java -jar <jar_file>

# Section 03_02: The persistence entities
- Using Java Persistence API (JPA)
- After we have identified the entity classes defining the business model, we need to define them, so they can be persitently stored
- Each entity class is defined with @Entity annotation, and corresponds to a table that is stored in the database:

    "@Entity
    public class Tour {...}"

- Entity attributes are defined with the @Column annotation. The @Id annotation is the primary key (unique identifier) of an entity:

    "@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column
    private String title;

    @Column(length = 2000)
    private String description;

    @Column(length = 2000)
    private String blurb;

    @Column
    private Integer price;"

- Entities, being classes, also have constructors, getters, and other relevant methods.
- Every instance of an entity will correspond to a row in the table.

# Section 03_03: Declare JPA repositories
- Spring Data (Repository) abstracts away any particaular data source

- The most basic repository in Java is a repository interface. It is only a marker and does not contain any methods:
- - public interface Repository<T,ID>
    T: Domain type the repositroy manages
    ID: Type of the entity ID

- CRUD Repository is a Spring Data artifact common to many types of data sources, extending from Repository.
  It declares methods for create, update, read and delete entities.
- - public interface CrudRepository<T,ID> extends Repository<T,ID>

- ListCrudRepository declares more methods that use list collections instead of iterables.
- - public interface ListCrudRepository<T,ID> extends CrudRepository<T,ID>

- JpaRepository extends from ListCrudRepository and adds even more methods for relational database sources.
- - public interface JpaRepository<T,ID> extends ListCrudRepository<T,ID>

- In the current application, we will extend our repositories from JpaRepository:

- For that, we create a repo folder under java/com/example/explorecalijpa.
- The create the TourPackageRepository.java and TourRepository.java classes that will host our repositories.
- Finally, make the imports and define the classes:
- - "package main.java.com.example.explorecalijpa.repo;
    import main.java.com.example.explorecalijpa.model.TourPackage;
    import org.springframework.data.repository.JpaRepository;

    public class TourPackageRepository extends JpaRepository<TourPackage,String>{
  
    }"

    "package main.java.com.example.explorecalijpa.repo;
    import com.example.explorecalijpa.model.Tour;
    import org.springframework.data.repository.JpaRepository;

    public class TourRepository extends JpaRepository<Tour,Integer>{
  
    }"

# Section 03_04: Spring Data JPA Repository dependency injection
- Inject the repositories into Spring Bean Services:
- - "@Service
    public class TourPackageService {
      //Dependency injection via autowire
      private TourPackagerepository tourPackageRepository;

      public TourPackageService(TourPackageRepository tourPackageRepository){
        this.tourPackagerepository = tourPackageRepository;
      }
      ...(Implement TourPackageService methods)...
    }"

    "@Service
    public class TourService {
      //Dependency inmjection via autowire
      private TourPackagerepository tourPackageRepository;
      private TourRepository tourRepository;

      public TourService(TourPackageRepository tourPackageRepository, TourRepository tourRepository){
        this.tourPackagerepository = tourPackageRepository;
        this.tourRepository = tourRepository;
      }
      ...(Implement TourService methods)...
    }"

# Section 03_05: Introduction to Spring Data query methods
- Spring data allows for easy implementation of medium to complex queries on repositories via property expression,e.g.:
- - All easy tours
- - Tours less than $800
- - Easy tours less than $800

- Rules for Property Expression: findBy
- - Define single return type: Class or Optional<Class>
- - or define multi return type: collection container (List, Iterable, Collection)
- - Begin the method signature with findBy, followed by the property name in camel case
- - Parameter(s) with data type of the entity attribute, e.g.:
    List<Tour> findByRegion(Region region);
    Optional<Tour> finodByTitle(String title);

- Rules for Property Expression: CountBy
- - The return type is long
- - Same rules as findBy, e.g.:
    long countByRegion(Region region);
    long countbyPrice(int price);