# Section 01_01: Inversion of Control Pattern
Spring is an open-source framework for Java applications that provides dependency injection of Spring Beans via 
Spring application context, which follows the inversion-of-control desing pattern.

Dependency Injection (DI) Principle
- Separates the usage of objects from the lifecycle of their dependent objects
- Creation of the dependencies of a class is managed outside the class
- Makes application more flexible and maintainable and easier to test 

Inversion-of-Control Framework
- Maintains lifecycle of an object and its dependencies
- Requires dependency injection
- Class "relinquishes control" to the framework

Spring Context
- Also known as spring container
- The core Spring inversion-of-control framework

Spring Bean
- Java object managed by the Spring application context
- Singleton scope by default
- Other scopes: prototype, request, session

DI Configuration
- Originally via XML files: difficult to manage
- Java classes:
  - Annotated method: @Bean method within an @Configuration class
  - Annotated class such as @Component, @Service, @Repository

# Section 01_02: Spring ApplicationContext and Spring Beans
- A SprinBeans class was created, defining the different Beans (repository, tourManagement and TravelAgent).
  This is the configuration for the dependency injection.

- A context was then loaded with the Spring Beans class in the main application: 
  "ApplicationContext context = new AnnotationConfigApplicationContext(SpringBeans.class);"

- Instantiation of TravelAgentService object was performed from the context Bean:
  "TravelAgentService agent = context.getBean(TravelAgentService.class);"

# Section 01_03: Spring autowiring annotations
- Another way to configure dependency injection is with autowiring

- For using the autowire functionality for DI, we need to annotate the different class layers:
- - Repository with @Repository
- - Services with @Service

- With these annotations we do not need the spring beans class that instantiates the class objects with explicit dependencies

- Since the spring beans class is removed, we need to adapt the instantiation of the context in the application. 
  We will scan for the dependency packages:
"ApplicationContext context = new AnnotationConfigApplicationContext(SpringBeans.class);"
                                           |
                                           V
"ApplicationContext context = new AnnotationConfigApplicationContext(Application.class.getPackageName());"

# Section 02_01: Introduction to Spring Initialzr
- Spring Initializr:
- - Is a tool for creating spring boot projects
- - Creates a packages structure
- - Creates the pom.xml/build.gradle files
- - Creates Java source classes

- Our first spring boot microservice will be a Web application for relational DB, requiring the dependencies:
- - Spring Web, which includes Tomcat and Spring MVC
- - Rest repositories to access Spring repositories via REST
- - Java persistence API (JPA)
- - Lombok: generates getters/setters/logger bytecode
- - H2 in memory database driver

# Section 02_03: Build, deploy, and launch the microservice
All steps via cli inside the project folder:
- Build: mvn clean install. A jar file for the application is built in the /target folder after the command terminates
- Run application: java -jar <jar_file>

# Section 03_02: The persistence entities
- Using Java Persistence API (JPA)
- After we have identified the entity classes defining the business model, we need to define them, so they can be persitently stored
- Each entity class is defined with @Entity annotation, and corresponds to a table that is stored in the database:

    "@Entity
    public class Tour {...}"

- Entity attributes are defined with the @Column annotation. The @Id annotation is the primary key (unique identifier) of an entity:

    "@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column
    private String title;

    @Column(length = 2000)
    private String description;

    @Column(length = 2000)
    private String blurb;

    @Column
    private Integer price;"

- Entities, being classes, also have constructors, getters, and other relevant methods.
- Every instance of an entity will correspond to a row in the table.


